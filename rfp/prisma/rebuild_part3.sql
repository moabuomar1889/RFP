-- Migration 014: Fix approve_request for upgrade scenarios
-- Returns existing folder ID for upgrades so we don't create a new root folder
-- Run this in Supabase SQL Editor

DROP FUNCTION IF EXISTS public.approve_request(UUID, TEXT);

CREATE OR REPLACE FUNCTION public.approve_request(
    p_request_id UUID,
    p_reviewed_by TEXT
)
RETURNS JSONB AS $$
DECLARE
    v_request RECORD;
    v_project_id UUID;
    v_existing_folder_id TEXT;
    v_existing_pr_number TEXT;
    v_existing_name TEXT;
BEGIN
    SELECT * INTO v_request
    FROM rfp.project_requests
    WHERE id = p_request_id AND status = 'pending';
    
    IF NOT FOUND THEN
        RETURN jsonb_build_object('success', false, 'error', 'Request not found or already processed');
    END IF;
    
    UPDATE rfp.project_requests
    SET status = 'approved',
        reviewed_by = p_reviewed_by,
        reviewed_at = NOW()
    WHERE id = p_request_id;
    
    IF v_request.request_type = 'new_project' THEN
        -- Create new project for new_project requests
        INSERT INTO rfp.projects (
            pr_number,
            name,
            status,
            phase,
            drive_folder_id
        ) VALUES (
            v_request.pr_number,
            v_request.project_name,
            'pending_creation',
            'bidding',
            ''
        )
        RETURNING id INTO v_project_id;
        
        -- Return info for new project (no existing folder)
        INSERT INTO rfp.audit_log (action, entity_type, entity_id, performed_by, details)
        VALUES ('request_approved', 'project_request', p_request_id::TEXT, p_reviewed_by,
                jsonb_build_object('request_type', v_request.request_type, 'project_name', v_request.project_name));
        
        RETURN jsonb_build_object(
            'success', true, 
            'project_id', v_project_id,
            'pr_number', v_request.pr_number,
            'project_name', v_request.project_name,
            'request_type', v_request.request_type,
            'phase', 'bidding',
            'existing_folder_id', NULL
        );
    END IF;
    
    IF v_request.request_type = 'upgrade_to_pd' AND v_request.project_id IS NOT NULL THEN
        -- Get existing project info for upgrade
        SELECT drive_folder_id, pr_number, name 
        INTO v_existing_folder_id, v_existing_pr_number, v_existing_name
        FROM rfp.projects
        WHERE id = v_request.project_id;
        
        -- Update phase to execution
        UPDATE rfp.projects
        SET phase = 'execution'
        WHERE id = v_request.project_id;
        
        v_project_id := v_request.project_id;
        
        INSERT INTO rfp.audit_log (action, entity_type, entity_id, performed_by, details)
        VALUES ('request_approved', 'project_request', p_request_id::TEXT, p_reviewed_by,
                jsonb_build_object('request_type', v_request.request_type, 'project_name', v_existing_name));
        
        -- Return existing folder ID for upgrade (don't create new root folder!)
        RETURN jsonb_build_object(
            'success', true, 
            'project_id', v_project_id,
            'pr_number', v_existing_pr_number,
            'project_name', v_existing_name,
            'request_type', v_request.request_type,
            'phase', 'execution',
            'existing_folder_id', v_existing_folder_id
        );
    END IF;
    
    RETURN jsonb_build_object('success', false, 'error', 'Unknown request type');
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION public.approve_request(UUID, TEXT) TO anon, authenticated, service_role;

-- ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
-- DIRECT SYNC RPCs
-- Functions for direct project sync without Inngest
-- Run this in Supabase SQL Editor
-- ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????

-- Upsert folder index entry
CREATE OR REPLACE FUNCTION public.upsert_folder_index(
    p_project_id UUID,
    p_template_path TEXT,
    p_drive_folder_id TEXT,
    p_drive_folder_name TEXT
)
RETURNS VOID AS $$
BEGIN
    INSERT INTO rfp.folder_index (project_id, template_path, drive_folder_id, drive_folder_name, last_verified_at)
    VALUES (p_project_id, p_template_path, p_drive_folder_id, p_drive_folder_name, NOW())
    ON CONFLICT (project_id, template_path) 
    DO UPDATE SET 
        drive_folder_id = EXCLUDED.drive_folder_id,
        drive_folder_name = EXCLUDED.drive_folder_name,
        last_verified_at = NOW();
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Update project sync timestamp
CREATE OR REPLACE FUNCTION public.update_project_sync(p_id UUID)
RETURNS VOID AS $$
BEGIN
    UPDATE rfp.projects
    SET last_synced_at = NOW()
    WHERE id = p_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Clear and rebuild folder index for a project
CREATE OR REPLACE FUNCTION public.clear_folder_index(p_project_id UUID)
RETURNS INTEGER AS $$
DECLARE
    deleted_count INTEGER;
BEGIN
    DELETE FROM rfp.folder_index WHERE project_id = p_project_id;
    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    RETURN deleted_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Get folder index for project
CREATE OR REPLACE FUNCTION public.get_folder_index(p_project_id UUID)
RETURNS TABLE (
    id UUID,
    project_id UUID,
    template_path TEXT,
    drive_folder_id TEXT,
    drive_folder_name TEXT,
    limited_access_enabled BOOLEAN,
    permission_status TEXT,
    last_verified_at TIMESTAMPTZ
) AS $$
BEGIN
    RETURN QUERY
    SELECT fi.id, fi.project_id, fi.template_path, fi.drive_folder_id, 
           fi.drive_folder_name, fi.limited_access_enabled, fi.permission_status,
           fi.last_verified_at
    FROM rfp.folder_index fi
    WHERE fi.project_id = p_project_id
    ORDER BY fi.template_path;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Grant permissions
GRANT EXECUTE ON FUNCTION public.upsert_folder_index(UUID, TEXT, TEXT, TEXT) TO anon, authenticated, service_role;
GRANT EXECUTE ON FUNCTION public.update_project_sync(UUID) TO anon, authenticated, service_role;
GRANT EXECUTE ON FUNCTION public.clear_folder_index(UUID) TO anon, authenticated, service_role;
GRANT EXECUTE ON FUNCTION public.get_folder_index(UUID) TO anon, authenticated, service_role;

-- ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
-- END OF MIGRATION
-- ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????

-- ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
-- PUBLIC WRAPPER FOR GET USERS WITH GROUPS
-- Run this in Supabase SQL Editor
-- ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????

-- Public wrapper for get_users_with_groups
CREATE OR REPLACE FUNCTION public.get_users_with_groups()
RETURNS TABLE (
    id UUID,
    google_id TEXT,
    email TEXT,
    name TEXT,
    given_name TEXT,
    family_name TEXT,
    photo_url TEXT,
    department TEXT,
    role TEXT,
    status TEXT,
    last_login TIMESTAMPTZ,
    synced_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ,
    groups TEXT[]
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        u.id, u.google_id, u.email, u.name, u.given_name, u.family_name,
        u.photo_url, u.department, u.role, u.status, u.last_login, 
        u.synced_at, u.created_at,
        COALESCE(ARRAY_AGG(g.name) FILTER (WHERE g.name IS NOT NULL), '{}') as groups
    FROM rfp.user_directory u
    LEFT JOIN rfp.user_group_membership m ON u.email = m.user_email
    LEFT JOIN rfp.group_directory g ON m.group_email = g.email
    GROUP BY u.id, u.google_id, u.email, u.name, u.given_name, u.family_name,
             u.photo_url, u.department, u.role, u.status, u.last_login, 
             u.synced_at, u.created_at
    ORDER BY u.name ASC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION public.get_users_with_groups() TO anon, authenticated, service_role;

-- Public wrapper for add_user_to_group
CREATE OR REPLACE FUNCTION public.add_user_to_group(
    p_user_email TEXT,
    p_group_email TEXT,
    p_added_by TEXT DEFAULT NULL
)
RETURNS UUID AS $$
DECLARE
    v_id UUID;
BEGIN
    INSERT INTO rfp.user_group_membership (user_email, group_email, added_by)
    VALUES (p_user_email, p_group_email, p_added_by)
    ON CONFLICT (user_email, group_email) DO NOTHING
    RETURNING id INTO v_id;
    
    RETURN v_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION public.add_user_to_group(TEXT, TEXT, TEXT) TO anon, authenticated, service_role;

-- ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
-- END OF MIGRATION
-- ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????

-- ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
-- FIX UPSERT PROJECT RPC
-- The original used ON CONFLICT (drive_folder_id) but pr_number is the unique key
-- Run this in Supabase SQL Editor
-- ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????

-- Fix upsert_project to conflict on pr_number (the actual unique constraint)
CREATE OR REPLACE FUNCTION public.upsert_project(
    p_pr_number TEXT,
    p_name TEXT,
    p_drive_folder_id TEXT,
    p_phase TEXT DEFAULT 'bidding'
)
RETURNS UUID AS $$
DECLARE
    v_id UUID;
BEGIN
    INSERT INTO rfp.projects (pr_number, name, drive_folder_id, phase, status)
    VALUES (p_pr_number, p_name, p_drive_folder_id, p_phase, 'active')
    ON CONFLICT (pr_number) DO UPDATE SET
        name = EXCLUDED.name,
        drive_folder_id = EXCLUDED.drive_folder_id,
        phase = EXCLUDED.phase
    RETURNING id INTO v_id;
    
    RETURN v_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION public.upsert_project(TEXT, TEXT, TEXT, TEXT) TO anon, authenticated, service_role;

-- ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
-- END OF MIGRATION
-- ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????

-- ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
-- GROUP MANAGEMENT RPCs
-- Run this in Supabase SQL Editor
-- ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????

-- Public wrapper for get_users_with_groups (already created in 016)
-- Here we add the remaining needed RPCs

-- Drop functions with different signatures first
DROP FUNCTION IF EXISTS public.get_user_by_id(UUID);
DROP FUNCTION IF EXISTS public.get_groups();

-- Get user by ID
CREATE OR REPLACE FUNCTION public.get_user_by_id(p_id UUID)
RETURNS TABLE (
    id UUID,
    email TEXT,
    name TEXT,
    role TEXT,
    department TEXT,
    status TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        u.id, u.email, u.name, u.role, u.department, u.status
    FROM rfp.user_directory u
    WHERE u.id = p_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION public.get_user_by_id(UUID) TO anon, authenticated, service_role;

-- Remove user from group
CREATE OR REPLACE FUNCTION public.remove_user_from_group(
    p_user_email TEXT,
    p_group_email TEXT
)
RETURNS VOID AS $$
BEGIN
    DELETE FROM rfp.user_group_membership 
    WHERE user_email = p_user_email 
    AND group_email = p_group_email;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION public.remove_user_from_group(TEXT, TEXT) TO anon, authenticated, service_role;

-- Get groups list
CREATE OR REPLACE FUNCTION public.get_groups()
RETURNS TABLE (
    id UUID,
    google_id TEXT,
    email TEXT,
    name TEXT,
    description TEXT,
    member_count INTEGER
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        g.id, g.google_id, g.email, g.name, g.description, g.member_count
    FROM rfp.group_directory g
    ORDER BY g.name;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION public.get_groups() TO anon, authenticated, service_role;

-- ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
-- END OF MIGRATION
-- ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????

-- ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
-- COMPLETE USER & GROUP MANAGEMENT RPCs
-- Run this ENTIRE script in Supabase SQL Editor
-- ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????

-- 1. Make sure user_group_membership table exists
CREATE TABLE IF NOT EXISTS rfp.user_group_membership (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_email TEXT NOT NULL,
    group_email TEXT NOT NULL,
    added_by TEXT,
    created_at TIMESTAMPTZ DEFAULT now(),
    UNIQUE(user_email, group_email)
);

-- 2. Get users with their groups
DROP FUNCTION IF EXISTS public.get_users_with_groups();
CREATE OR REPLACE FUNCTION public.get_users_with_groups()
RETURNS TABLE (
    id UUID,
    google_id TEXT,
    email TEXT,
    name TEXT,
    given_name TEXT,
    family_name TEXT,
    photo_url TEXT,
    department TEXT,
    role TEXT,
    status TEXT,
    last_login TIMESTAMPTZ,
    synced_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ,
    groups TEXT[]
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        u.id, u.google_id, u.email, u.name, u.given_name, u.family_name,
        u.photo_url, u.department, u.role, u.status, u.last_login, 
        u.synced_at, u.created_at,
        COALESCE(ARRAY_AGG(g.name) FILTER (WHERE g.name IS NOT NULL), '{}') as groups
    FROM rfp.user_directory u
    LEFT JOIN rfp.user_group_membership m ON LOWER(u.email) = LOWER(m.user_email)
    LEFT JOIN rfp.group_directory g ON LOWER(m.group_email) = LOWER(g.email)
    GROUP BY u.id, u.google_id, u.email, u.name, u.given_name, u.family_name,
             u.photo_url, u.department, u.role, u.status, u.last_login, 
             u.synced_at, u.created_at
    ORDER BY u.name ASC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION public.get_users_with_groups() TO anon, authenticated, service_role;

-- 3. Add user to group
DROP FUNCTION IF EXISTS public.add_user_to_group(TEXT, TEXT, TEXT);
CREATE OR REPLACE FUNCTION public.add_user_to_group(
    p_user_email TEXT,
    p_group_email TEXT,
    p_added_by TEXT DEFAULT 'admin'
)
RETURNS UUID AS $$
DECLARE
    v_id UUID;
BEGIN
    INSERT INTO rfp.user_group_membership (user_email, group_email, added_by)
    VALUES (LOWER(p_user_email), LOWER(p_group_email), p_added_by)
    ON CONFLICT (user_email, group_email) DO UPDATE SET added_by = p_added_by
    RETURNING id INTO v_id;
    
    RETURN v_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION public.add_user_to_group(TEXT, TEXT, TEXT) TO anon, authenticated, service_role;

-- 4. Remove user from group
DROP FUNCTION IF EXISTS public.remove_user_from_group(TEXT, TEXT);
CREATE OR REPLACE FUNCTION public.remove_user_from_group(
    p_user_email TEXT,
    p_group_email TEXT
)
RETURNS VOID AS $$
BEGIN
    DELETE FROM rfp.user_group_membership 
    WHERE LOWER(user_email) = LOWER(p_user_email) 
    AND LOWER(group_email) = LOWER(p_group_email);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION public.remove_user_from_group(TEXT, TEXT) TO anon, authenticated, service_role;

-- 5. Get user by ID
DROP FUNCTION IF EXISTS public.get_user_by_id(UUID);
CREATE OR REPLACE FUNCTION public.get_user_by_id(p_id UUID)
RETURNS TABLE (
    id UUID,
    email TEXT,
    name TEXT,
    role TEXT,
    department TEXT,
    status TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        u.id, u.email, u.name, u.role, u.department, u.status
    FROM rfp.user_directory u
    WHERE u.id = p_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION public.get_user_by_id(UUID) TO anon, authenticated, service_role;

-- 6. Get all groups
DROP FUNCTION IF EXISTS public.get_groups();
CREATE OR REPLACE FUNCTION public.get_groups()
RETURNS TABLE (
    id UUID,
    google_id TEXT,
    email TEXT,
    name TEXT,
    description TEXT,
    member_count INTEGER
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        g.id, g.google_id, g.email, g.name, g.description, g.member_count
    FROM rfp.group_directory g
    ORDER BY g.name;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION public.get_groups() TO anon, authenticated, service_role;

-- ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
-- END - Run this entire script in Supabase SQL Editor
-- ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????


-- Migration: Update approve_request to return more info + add update_project_folder RPC
-- Run this in Supabase SQL Editor

-- Drop existing functions
DROP FUNCTION IF EXISTS public.approve_request(UUID, TEXT);
DROP FUNCTION IF EXISTS public.update_project_folder(UUID, TEXT);

-- Recreate approve_request with more return values
CREATE OR REPLACE FUNCTION public.approve_request(
    p_request_id UUID,
    p_reviewed_by TEXT
)
RETURNS JSONB AS $$
DECLARE
    v_request RECORD;
    v_project_id UUID;
BEGIN
    SELECT * INTO v_request
    FROM rfp.project_requests
    WHERE id = p_request_id AND status = 'pending';
    
    IF NOT FOUND THEN
        RETURN jsonb_build_object('success', false, 'error', 'Request not found or already processed');
    END IF;
    
    UPDATE rfp.project_requests
    SET status = 'approved',
        reviewed_by = p_reviewed_by,
        reviewed_at = NOW()
    WHERE id = p_request_id;
    
    IF v_request.request_type = 'new_project' THEN
        INSERT INTO rfp.projects (
            pr_number,
            name,
            status,
            phase,
            drive_folder_id
        ) VALUES (
            v_request.pr_number,
            v_request.project_name,
            'pending_creation',
            'bidding',
            ''
        )
        RETURNING id INTO v_project_id;
    END IF;
    
    IF v_request.request_type = 'upgrade_to_pd' AND v_request.project_id IS NOT NULL THEN
        UPDATE rfp.projects
        SET phase = 'execution'
        WHERE id = v_request.project_id;
        v_project_id := v_request.project_id;
    END IF;
    
    INSERT INTO rfp.audit_log (action, entity_type, entity_id, performed_by, details)
    VALUES ('request_approved', 'project_request', p_request_id::TEXT, p_reviewed_by,
            jsonb_build_object('request_type', v_request.request_type, 'project_name', v_request.project_name));
    
    -- Return more info needed for folder creation
    RETURN jsonb_build_object(
        'success', true, 
        'project_id', v_project_id,
        'pr_number', v_request.pr_number,
        'project_name', v_request.project_name,
        'request_type', v_request.request_type
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create the function to update project with folder ID and set to active
CREATE OR REPLACE FUNCTION public.update_project_folder(
    p_project_id UUID,
    p_drive_folder_id TEXT
)
RETURNS JSONB AS $$
BEGIN
    UPDATE rfp.projects 
    SET 
        drive_folder_id = p_drive_folder_id,
        status = 'active'
    WHERE id = p_project_id;
    
    IF NOT FOUND THEN
        RETURN jsonb_build_object('success', false, 'error', 'Project not found');
    END IF;
    
    RETURN jsonb_build_object('success', true);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Grant execute permissions
GRANT EXECUTE ON FUNCTION public.approve_request(UUID, TEXT) TO anon, authenticated;
GRANT EXECUTE ON FUNCTION public.update_project_folder(UUID, TEXT) TO anon, authenticated;

-- Migration: Add upsert_user_token RPC that handles NULL refresh token
-- Google only provides refresh_token on first authorization
-- On subsequent logins, we must preserve the existing refresh_token
-- Run this in Supabase SQL Editor

-- Drop if exists
DROP FUNCTION IF EXISTS public.upsert_user_token(TEXT, TEXT, TEXT, TIMESTAMPTZ);

-- Create the function
CREATE OR REPLACE FUNCTION public.upsert_user_token(
    p_email TEXT,
    p_access_token TEXT,
    p_refresh_token TEXT,
    p_token_expiry TIMESTAMPTZ
)
RETURNS JSONB AS $$
DECLARE
    v_existing_refresh TEXT;
BEGIN
    -- If refresh_token is null, try to get existing one
    IF p_refresh_token IS NULL THEN
        SELECT refresh_token_encrypted INTO v_existing_refresh
        FROM rfp.user_tokens
        WHERE email = p_email;
        
        -- If no existing refresh token, we can't proceed
        IF v_existing_refresh IS NULL THEN
            RETURN jsonb_build_object('success', false, 'error', 'No refresh token available');
        END IF;
    ELSE
        v_existing_refresh := p_refresh_token;
    END IF;
    
    -- Upsert the token
    INSERT INTO rfp.user_tokens (email, access_token_encrypted, refresh_token_encrypted, token_expiry, updated_at)
    VALUES (p_email, p_access_token, v_existing_refresh, p_token_expiry, NOW())
    ON CONFLICT (email) 
    DO UPDATE SET
        access_token_encrypted = EXCLUDED.access_token_encrypted,
        refresh_token_encrypted = COALESCE(NULLIF(EXCLUDED.refresh_token_encrypted, ''), rfp.user_tokens.refresh_token_encrypted),
        token_expiry = EXCLUDED.token_expiry,
        updated_at = NOW();
    
    RETURN jsonb_build_object('success', true);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Grant execute permission
GRANT EXECUTE ON FUNCTION public.upsert_user_token(TEXT, TEXT, TEXT, TIMESTAMPTZ) TO anon, authenticated;

-- ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
-- INSERT FOLDER INDEX RPC (RFP SCHEMA)
-- Run this in Supabase SQL Editor  
-- ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????

-- Drop existing function if exists
DROP FUNCTION IF EXISTS rfp.insert_folder_index(UUID, TEXT, TEXT, TEXT, BOOLEAN);
DROP FUNCTION IF EXISTS public.insert_folder_index(UUID, TEXT, TEXT, TEXT, BOOLEAN);

-- Insert folder index entry
CREATE OR REPLACE FUNCTION rfp.insert_folder_index(
    p_project_id UUID,
    p_template_path TEXT,
    p_drive_folder_id TEXT,
    p_drive_folder_name TEXT,
    p_limited_access_enabled BOOLEAN DEFAULT false
)
RETURNS UUID AS $$
DECLARE
    v_id UUID;
BEGIN
    INSERT INTO rfp.folder_index (
        project_id,
        template_path,
        drive_folder_id,
        drive_folder_name,
        limited_access_enabled
    )
    VALUES (
        p_project_id,
        p_template_path,
        p_drive_folder_id,
        p_drive_folder_name,
        p_limited_access_enabled
    )
    ON CONFLICT (drive_folder_id) DO UPDATE SET
        template_path = EXCLUDED.template_path,
        drive_folder_name = EXCLUDED.drive_folder_name,
        limited_access_enabled = EXCLUDED.limited_access_enabled
    RETURNING id INTO v_id;
    
    RETURN v_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Grant permissions
GRANT EXECUTE ON FUNCTION rfp.insert_folder_index(UUID, TEXT, TEXT, TEXT, BOOLEAN) TO anon, authenticated, service_role;

-- ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
-- END OF MIGRATION
-- ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????

-- ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
-- USER GROUP MEMBERSHIP - Track which groups users belong to
-- Run this in Supabase SQL Editor
-- ALL OBJECTS IN RFP SCHEMA
-- ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????

-- ???????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
-- USER GROUP MEMBERSHIP TABLE
-- ???????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
CREATE TABLE IF NOT EXISTS rfp.user_group_membership (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_email TEXT NOT NULL,
    group_email TEXT NOT NULL,
    added_at TIMESTAMPTZ DEFAULT NOW(),
    added_by TEXT,
    UNIQUE(user_email, group_email)
);

CREATE INDEX IF NOT EXISTS idx_user_group_member_user ON rfp.user_group_membership(user_email);
CREATE INDEX IF NOT EXISTS idx_user_group_member_group ON rfp.user_group_membership(group_email);

-- ???????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
-- RPC FUNCTIONS (ALL IN RFP SCHEMA)
-- ???????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????

-- Get groups for a user
CREATE OR REPLACE FUNCTION rfp.get_user_groups(p_user_email TEXT)
RETURNS TABLE (
    id UUID,
    google_id TEXT,
    email TEXT,
    name TEXT,
    description TEXT,
    member_count INTEGER,
    mapped_role TEXT,
    synced_at TIMESTAMPTZ,
    added_at TIMESTAMPTZ
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        g.id, g.google_id, g.email, g.name, g.description,
        g.member_count, g.mapped_role, g.synced_at,
        m.added_at
    FROM rfp.group_directory g
    INNER JOIN rfp.user_group_membership m ON g.email = m.group_email
    WHERE m.user_email = p_user_email
    ORDER BY g.name ASC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Add user to group
CREATE OR REPLACE FUNCTION rfp.add_user_to_group(
    p_user_email TEXT,
    p_group_email TEXT,
    p_added_by TEXT DEFAULT NULL
)
RETURNS UUID AS $$
DECLARE
    v_id UUID;
BEGIN
    INSERT INTO rfp.user_group_membership (user_email, group_email, added_by)
    VALUES (p_user_email, p_group_email, p_added_by)
    ON CONFLICT (user_email, group_email) DO NOTHING
    RETURNING id INTO v_id;
    
    RETURN v_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Remove user from group
CREATE OR REPLACE FUNCTION rfp.remove_user_from_group(
    p_user_email TEXT,
    p_group_email TEXT
)
RETURNS BOOLEAN AS $$
BEGIN
    DELETE FROM rfp.user_group_membership
    WHERE user_email = p_user_email AND group_email = p_group_email;
    
    RETURN FOUND;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Get all users with their groups (for efficient loading)
CREATE OR REPLACE FUNCTION rfp.get_users_with_groups()
RETURNS TABLE (
    id UUID,
    google_id TEXT,
    email TEXT,
    name TEXT,
    given_name TEXT,
    family_name TEXT,
    photo_url TEXT,
    department TEXT,
    role TEXT,
    status TEXT,
    last_login TIMESTAMPTZ,
    synced_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ,
    groups TEXT[]
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        u.id, u.google_id, u.email, u.name, u.given_name, u.family_name,
        u.photo_url, u.department, u.role, u.status, u.last_login, 
        u.synced_at, u.created_at,
        COALESCE(ARRAY_AGG(g.name) FILTER (WHERE g.name IS NOT NULL), '{}') as groups
    FROM rfp.user_directory u
    LEFT JOIN rfp.user_group_membership m ON u.email = m.user_email
    LEFT JOIN rfp.group_directory g ON m.group_email = g.email
    GROUP BY u.id, u.google_id, u.email, u.name, u.given_name, u.family_name,
             u.photo_url, u.department, u.role, u.status, u.last_login, 
             u.synced_at, u.created_at
    ORDER BY u.name ASC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ???????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
-- GRANT PERMISSIONS
-- ???????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
GRANT EXECUTE ON FUNCTION rfp.get_user_groups(TEXT) TO anon, authenticated, service_role;
GRANT EXECUTE ON FUNCTION rfp.add_user_to_group(TEXT, TEXT, TEXT) TO anon, authenticated, service_role;
GRANT EXECUTE ON FUNCTION rfp.remove_user_from_group(TEXT, TEXT) TO anon, authenticated, service_role;
GRANT EXECUTE ON FUNCTION rfp.get_users_with_groups() TO anon, authenticated, service_role;

-- ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
-- END OF MIGRATION
-- ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????

-- ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
-- DASHBOARD STATS RPCs (RFP SCHEMA)
-- Run this in Supabase SQL Editor
-- ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????

-- Get folder count
CREATE OR REPLACE FUNCTION rfp.get_folder_count()
RETURNS INTEGER AS $$
BEGIN
    RETURN (SELECT COUNT(*) FROM rfp.folder_index);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Get pending requests count
CREATE OR REPLACE FUNCTION rfp.get_pending_requests_count()
RETURNS INTEGER AS $$
BEGIN
    RETURN (SELECT COUNT(*) FROM rfp.project_requests WHERE status = 'pending');
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Get unresolved violations count
CREATE OR REPLACE FUNCTION rfp.get_violations_count()
RETURNS INTEGER AS $$
BEGIN
    RETURN (SELECT COUNT(*) FROM rfp.permission_violations WHERE resolved_at IS NULL);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Get active jobs count
CREATE OR REPLACE FUNCTION rfp.get_active_jobs_count()
RETURNS INTEGER AS $$
BEGIN
    RETURN (SELECT COUNT(*) FROM rfp.sync_jobs WHERE status = 'running');
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Get last scan time
CREATE OR REPLACE FUNCTION rfp.get_last_scan_time()
RETURNS TIMESTAMPTZ AS $$
BEGIN
    RETURN (
        SELECT completed_at 
        FROM rfp.sync_jobs 
        WHERE status = 'completed' 
        ORDER BY completed_at DESC 
        LIMIT 1
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Grant permissions
GRANT EXECUTE ON FUNCTION rfp.get_folder_count() TO anon, authenticated, service_role;
GRANT EXECUTE ON FUNCTION rfp.get_pending_requests_count() TO anon, authenticated, service_role;
GRANT EXECUTE ON FUNCTION rfp.get_violations_count() TO anon, authenticated, service_role;
GRANT EXECUTE ON FUNCTION rfp.get_active_jobs_count() TO anon, authenticated, service_role;
GRANT EXECUTE ON FUNCTION rfp.get_last_scan_time() TO anon, authenticated, service_role;

-- ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
-- END OF MIGRATION
-- ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????

-- ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
-- PROJECT DELETE RPCs 
-- These are PUBLIC SCHEMA wrappers that access RFP schema tables
-- This follows the same pattern as other RPCs (get_project_by_id, get_projects, etc.)
-- Run this in Supabase SQL Editor
-- ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????

-- Delete folder_index entries for a project
-- Function is in public schema (so RPC can find it)
-- but operates on rfp.folder_index table
CREATE OR REPLACE FUNCTION public.delete_folder_index_by_project(p_project_id UUID)
RETURNS VOID AS $$
BEGIN
    DELETE FROM rfp.folder_index WHERE project_id = p_project_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Delete a project from the database
-- Function is in public schema but operates on rfp.projects table
CREATE OR REPLACE FUNCTION public.delete_project(p_id UUID)
RETURNS VOID AS $$
BEGIN
    DELETE FROM rfp.projects WHERE id = p_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Grant permissions
GRANT EXECUTE ON FUNCTION public.delete_folder_index_by_project(UUID) TO anon, authenticated, service_role;
GRANT EXECUTE ON FUNCTION public.delete_project(UUID) TO anon, authenticated, service_role;

-- ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
-- END OF MIGRATION
-- ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????

-- ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
-- SYNC JOB RPCs (FIXED COLUMN NAMES)
-- Functions for creating and managing sync jobs
-- Run this in Supabase SQL Editor
-- ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????

-- Get active template version
CREATE OR REPLACE FUNCTION public.get_active_template_version()
RETURNS INTEGER AS $$
DECLARE
    v_version INTEGER;
BEGIN
    SELECT version_number INTO v_version
    FROM rfp.template_versions
    WHERE is_active = true
    LIMIT 1;
    
    RETURN COALESCE(v_version, 1);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create sync job (using correct column names: started_by, metadata)
CREATE OR REPLACE FUNCTION public.create_sync_job(
    p_id UUID,
    p_job_type TEXT,
    p_status TEXT,
    p_triggered_by TEXT,
    p_job_details JSONB
)
RETURNS UUID AS $$
BEGIN
    INSERT INTO rfp.sync_jobs (id, job_type, status, started_by, metadata)
    VALUES (p_id, p_job_type, p_status, p_triggered_by, p_job_details);
    
    RETURN p_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Update sync job status
CREATE OR REPLACE FUNCTION public.update_sync_job_status(
    p_id UUID,
    p_status TEXT,
    p_result JSONB DEFAULT NULL
)
RETURNS VOID AS $$
BEGIN
    UPDATE rfp.sync_jobs
    SET status = p_status,
        metadata = COALESCE(p_result, metadata),
        completed_at = CASE WHEN p_status IN ('completed', 'failed') THEN NOW() ELSE completed_at END
    WHERE id = p_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Log audit entry (using correct table: audit_log not audit_logs)
CREATE OR REPLACE FUNCTION public.log_audit(
    p_action TEXT,
    p_entity_type TEXT,
    p_entity_id TEXT,
    p_performed_by TEXT,
    p_details JSONB DEFAULT '{}'::JSONB
)
RETURNS UUID AS $$
DECLARE
    v_id UUID;
BEGIN
    INSERT INTO rfp.audit_log (action, entity_type, entity_id, performed_by, details)
    VALUES (p_action, p_entity_type, p_entity_id, p_performed_by, p_details)
    RETURNING id INTO v_id;
    
    RETURN v_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Grant permissions
GRANT EXECUTE ON FUNCTION public.get_active_template_version() TO anon, authenticated, service_role;
GRANT EXECUTE ON FUNCTION public.create_sync_job(UUID, TEXT, TEXT, TEXT, JSONB) TO anon, authenticated, service_role;
GRANT EXECUTE ON FUNCTION public.update_sync_job_status(UUID, TEXT, JSONB) TO anon, authenticated, service_role;
GRANT EXECUTE ON FUNCTION public.log_audit(TEXT, TEXT, TEXT, TEXT, JSONB) TO anon, authenticated, service_role;

-- ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
-- END OF MIGRATION
-- ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????

